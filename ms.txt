1.set和list的区别
	set:去重,无序。
	list:不去重,有序,有索引。

2.spingMVC的怎样处理一个请求。
	1.用户发出一个请求,请求发送到DisPatcherServlet(前端控制器)
	2.前端控制器找到HandlerMapping(映射器),handlerMapping在通过访问的url找到HandlerAdapter(适配器),适配器处理请求,返回modelAndView视图,modelAndView中的数据显示到页面上!

3.spring的优点
	1.降低了组合件之间的耦合度(依赖注入DI和工厂模式,让调用更方便)。
	2.提供了众多服务,如事物管理和消息服务。
	3.提供了aop技术,容易实现权限拦截,运行期监控等功能。
	4.对主流框架提供了集成支持。
	5.spring低侵入(例如struts2要继承一些特定的类,spring不需要,方便应用迁移)

4.ioc(控制反转)和aop和依赖注入（DI）的原理
	ioc:通过第三方(spring容器)实现具有依赖关系的对象。（通俗点就是把对象A放入spring容器中,通过容器可以获取到a的关联对象。）。ioc的基础技术就是反射!可以看做工厂模式的升华,通过xml进行了灵活配置。
	aop:面向切面编程，把散落在程序中的公共部分提取出来，做成切面类，这样的好处在于，代码的可重用，一旦涉及到该功能的需求发生变化，只要修改该代码就行，否则，你要到处修改，如果只要修改1、2处那还可以接受，万一有1000处呢。 
	AOP底层的东西就是JDK动态代理和CGLIB代理，说白了就是增强类的功能。最常用的AOP应用在数据库连接以及事务处理上
	
5.spring事物管理方式有哪些?
	1.每一给bean一个代理(相当一每个dao都放到xml中)
	2.所有的bean共享一个代理(类似baseDao)	
	3.拦截器的方式
	4.tx标签
	5.注解
	
6.隔离级别
	脏读（Dirty read）-- 脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。
	不可重复读（Nonrepeatable read）-- 不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。
	幻影读（Phantom reads）-- 幻影读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻影读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。
	ISOLATION_DEFAULT	使用后端数据库默认的隔离级别。
	ISOLATION_READ_UNCOMMITTED	允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。
	ISOLATION_READ_COMMITTED	允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。
	ISOLATION_REPEATABLE_READ	对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。
	ISOLATION_SERIALIZABLE	完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。

7.事物的传播特性
	PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。(1.2保存成功3.失败，全部回滚)
	PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。(1.2保存成功3.失败，结果1.2保存)
	PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。
	PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。
	PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。(例如A支持事物,B不支持事物,a中如果调用了B,等b执行完成以后,在执行a以事物的方式)
	PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。
	PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。

